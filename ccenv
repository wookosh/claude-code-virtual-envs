#!/usr/bin/env python3
"""ccenv — Claude Code Environments

Manages reusable configuration profiles for Claude Code.
"""

import argparse
import difflib
import hashlib
import os
import shutil
import sys
from pathlib import Path

VERSION = "1.0.0"
PROFILES_DIR = Path.home() / ".claude-profiles"
PROFILE_MARKER = ".profile"

# Files/dirs that belong to a profile (managed by ccenv)
PROFILE_FILES = ("settings.json", "CLAUDE.md")
PROFILE_DIRS = ("agents", "skills", "rules")


def die(msg: str) -> None:
    print(f"ccenv: {msg}", file=sys.stderr)
    sys.exit(1)


def confirm(prompt: str = "Continue?") -> bool:
    try:
        answer = input(f"{prompt} [y/N] ")
    except (EOFError, KeyboardInterrupt):
        print()
        return False
    return answer.strip().lower() in ("y", "yes")


def ensure_profiles_dir() -> None:
    if PROFILES_DIR.exists():
        return
    default = PROFILES_DIR / "_default"
    default.mkdir(parents=True)
    (default / "settings.json").write_text("{}\n")
    (default / "CLAUDE.md").write_text("# Claude Code\n\nAdd your system instructions here.\n")
    (default / "agents").mkdir()
    (default / "skills").mkdir()
    (default / "rules").mkdir()
    print(f"Created {PROFILES_DIR} with _default profile.")
    print('Tip: run "ccenv save original --from global" to preserve your existing config.')


def compute_hash(directory: Path) -> str:
    h = hashlib.sha256()
    for f in PROFILE_FILES:
        p = directory / f
        if p.is_file():
            h.update(p.read_bytes())
    for d in PROFILE_DIRS:
        p = directory / d
        if p.is_dir():
            for fp in sorted(p.rglob("*")):
                if fp.is_file():
                    h.update(fp.read_bytes())
    return h.hexdigest()


def copy_profile_files(src: Path, dst: Path) -> None:
    dst.mkdir(parents=True, exist_ok=True)
    for f in PROFILE_FILES:
        sp = src / f
        if sp.is_file():
            shutil.copy2(sp, dst / f)
    for d in PROFILE_DIRS:
        sp = src / d
        dp = dst / d
        if sp.is_dir():
            if dp.exists():
                shutil.rmtree(dp)
            shutil.copytree(sp, dp)


def remove_profile_files(directory: Path) -> None:
    for f in PROFILE_FILES:
        p = directory / f
        if p.is_file():
            p.unlink()
    for d in PROFILE_DIRS:
        p = directory / d
        if p.is_dir():
            shutil.rmtree(p)


def write_marker(claude_dir: Path, name: str, hash_val: str) -> None:
    (claude_dir / PROFILE_MARKER).write_text(f"{name}\n{hash_val}\n")


def read_marker(claude_dir: Path) -> tuple[str, str] | None:
    marker = claude_dir / PROFILE_MARKER
    if not marker.is_file():
        return None
    lines = marker.read_text().splitlines()
    name = lines[0] if len(lines) > 0 else ""
    hash_val = lines[1] if len(lines) > 1 else ""
    return name, hash_val


def count_md_files(directory: Path, subdir: str) -> int:
    p = directory / subdir
    if not p.is_dir():
        return 0
    return sum(1 for f in p.rglob("*.md") if f.is_file())


def count_skills(directory: Path) -> int:
    p = directory / "skills"
    if not p.is_dir():
        return 0
    return sum(1 for f in p.rglob("SKILL.md") if f.is_file())


def file_lines(path: Path) -> list[str]:
    if not path.is_file():
        return []
    return path.read_text().splitlines(keepends=True)


def collect_relative_files(directory: Path) -> set[str]:
    if not directory.is_dir():
        return set()
    return {str(f.relative_to(directory)) for f in sorted(directory.rglob("*")) if f.is_file()}


# ─── Commands ──────────────────────────────────────────────────────────────────


def cmd_save(args: argparse.Namespace) -> None:
    name: str = args.name
    source: str = args.source

    ensure_profiles_dir()

    if source == "global":
        source_dir = Path.home() / ".claude"
    elif source == "project":
        source_dir = Path.cwd() / ".claude"
    else:
        die("save: --from must be 'global' or 'project'")
        return  # unreachable, for type checker

    if not source_dir.is_dir():
        die(f"save: source directory '{source_dir}' does not exist")

    profile_dir = PROFILES_DIR / name
    if profile_dir.is_dir():
        if not confirm(f"Profile '{name}' already exists. Overwrite?"):
            print("Aborted.")
            return
        shutil.rmtree(profile_dir)

    profile_dir.mkdir(parents=True)
    copy_profile_files(source_dir, profile_dir)

    print(f'Profile "{name}" saved from {source} config.')
    print(f"Location: {profile_dir}")


def cmd_use(args: argparse.Namespace) -> None:
    name: str = args.name

    ensure_profiles_dir()

    profile_dir = PROFILES_DIR / name
    if not profile_dir.is_dir():
        die(f"use: profile '{name}' not found in {PROFILES_DIR}")

    claude_dir = Path.cwd() / ".claude"

    if claude_dir.is_dir():
        marker = read_marker(claude_dir)
        if marker is not None:
            marker_name, _ = marker
            if marker_name == name:
                if not confirm(f"Profile '{name}' is already active. Re-apply?"):
                    print("Aborted.")
                    return
            else:
                if not confirm(f"Profile '{marker_name}' is currently active. Switch to '{name}'?"):
                    print("Aborted.")
                    return
        else:
            has_content = any(
                (claude_dir / f).is_file() for f in PROFILE_FILES
            ) or any(
                (claude_dir / d).is_dir() for d in PROFILE_DIRS
            )
            if has_content:
                print("Warning: .claude/ has untracked config (no profile marker).")
                print('Consider running "ccenv save <name> --from project" first to preserve it.')
                if not confirm("Overwrite managed files?"):
                    print("Aborted.")
                    return

    if claude_dir.is_dir():
        remove_profile_files(claude_dir)
    copy_profile_files(profile_dir, claude_dir)

    hash_val = compute_hash(profile_dir)
    write_marker(claude_dir, name, hash_val)

    print(f'Profile "{name}" applied to .claude/')
    print("Launch Claude Code with: claude --setting-sources project,local")


def cmd_eject(_args: argparse.Namespace) -> None:
    claude_dir = Path.cwd() / ".claude"
    marker = read_marker(claude_dir)
    if marker is None:
        die("eject: no active profile in this project")
        return

    marker_name, _ = marker
    (claude_dir / PROFILE_MARKER).unlink()

    print(f'Ejected from profile "{marker_name}".')
    print("Project is now independent. Changes here won't affect the profile.")


def cmd_clear(args: argparse.Namespace) -> None:
    scope: str = args.scope

    if scope == "global":
        claude_dir = Path.home() / ".claude"
        label = "global (~/.claude/)"
    else:
        claude_dir = Path.cwd() / ".claude"
        label = "project (.claude/)"

    if not claude_dir.is_dir():
        die(f"clear: {label} directory does not exist")

    # Check what's actually there
    managed_files = [f for f in PROFILE_FILES if (claude_dir / f).is_file()]
    managed_dirs = [d for d in PROFILE_DIRS if (claude_dir / d).is_dir()]
    marker = read_marker(claude_dir)

    if not managed_files and not managed_dirs:
        print(f"Nothing to clear in {label}.")
        return

    print(f"This will remove from {label}:")
    for f in managed_files:
        print(f"  {f}")
    for d in managed_dirs:
        count = sum(1 for _ in (claude_dir / d).rglob("*") if _.is_file())
        print(f"  {d}/ ({count} file{'s' if count != 1 else ''})")
    if marker:
        print(f"  .profile (marker for '{marker[0]}')")

    print()
    if not confirm("Remove all managed files?"):
        print("Aborted.")
        return

    remove_profile_files(claude_dir)
    if marker:
        (claude_dir / PROFILE_MARKER).unlink()

    print(f"Cleared managed files from {label}.")


def cmd_status(_args: argparse.Namespace) -> None:
    ensure_profiles_dir()

    claude_dir = Path.cwd() / ".claude"
    marker = read_marker(claude_dir)

    if marker is not None:
        marker_name, marker_hash = marker
        print(f"Active profile: {marker_name}")

        profile_dir = PROFILES_DIR / marker_name
        if profile_dir.is_dir():
            current_hash = compute_hash(claude_dir)
            template_hash = compute_hash(profile_dir)

            if current_hash == marker_hash and current_hash == template_hash:
                print("Status: in sync with template")
            else:
                if current_hash != marker_hash:
                    print("Status: project files have drifted from applied profile")
                if template_hash != marker_hash:
                    print("Status: profile template has been updated since last apply")
                print('Run "ccenv update" to re-sync or "ccenv diff" to see changes.')
        else:
            print(f'Warning: profile "{marker_name}" no longer exists in {PROFILES_DIR}')
    else:
        print("No profile active in this project.")

    print()
    print("Available profiles:")
    _print_profile_list()


def cmd_update(_args: argparse.Namespace) -> None:
    claude_dir = Path.cwd() / ".claude"
    marker = read_marker(claude_dir)
    if marker is None:
        die("update: no active profile in this project")
        return

    name, _ = marker
    profile_dir = PROFILES_DIR / name
    if not profile_dir.is_dir():
        die(f"update: profile '{name}' not found in {PROFILES_DIR}")

    print(f'Comparing project .claude/ against profile "{name}"...\n')

    # Show what would change — files
    for f in PROFILE_FILES:
        pf = profile_dir / f
        cf = claude_dir / f
        if pf.is_file() and cf.is_file():
            if pf.read_bytes() != cf.read_bytes():
                print(f"  modified: {f}")
        elif pf.is_file() and not cf.is_file():
            print(f"  added:    {f}")
        elif not pf.is_file() and cf.is_file():
            print(f"  removed:  {f}")

    # Show what would change — dirs
    for d in PROFILE_DIRS:
        pd = profile_dir / d
        cd = claude_dir / d
        profile_files = collect_relative_files(pd)
        project_files = collect_relative_files(cd)
        all_files = sorted(profile_files | project_files)
        for rf in all_files:
            in_profile = (pd / rf).is_file()
            in_project = (cd / rf).is_file()
            if in_profile and in_project:
                if (pd / rf).read_bytes() != (cd / rf).read_bytes():
                    print(f"  modified: {d}/{rf}")
            elif in_profile:
                print(f"  added:    {d}/{rf}")
            else:
                print(f"  removed:  {d}/{rf}")

    current_hash = compute_hash(claude_dir)
    template_hash = compute_hash(profile_dir)

    if current_hash == template_hash:
        print("Already up to date.")
        return

    print()
    if not confirm(f"Apply changes from profile '{name}'?"):
        print("Aborted.")
        return

    remove_profile_files(claude_dir)
    copy_profile_files(profile_dir, claude_dir)

    new_hash = compute_hash(profile_dir)
    write_marker(claude_dir, name, new_hash)

    print(f'Updated to latest "{name}" profile.')


def cmd_list(_args: argparse.Namespace) -> None:
    ensure_profiles_dir()
    _print_profile_list()


def _print_profile_list() -> None:
    profiles = sorted(p for p in PROFILES_DIR.iterdir() if p.is_dir())
    if not profiles:
        print("  (no profiles found)")
        return

    for profile_dir in profiles:
        name = profile_dir.name
        agents = count_md_files(profile_dir, "agents")
        skills = count_skills(profile_dir)
        rules = count_md_files(profile_dir, "rules")
        has_claude_md = "yes" if (profile_dir / "CLAUDE.md").is_file() else "no"
        print(f"  {name:<20}  agents:{agents}  skills:{skills}  rules:{rules}  CLAUDE.md:{has_claude_md}")


def cmd_diff(args: argparse.Namespace) -> None:
    name: str | None = args.name

    ensure_profiles_dir()

    claude_dir = Path.cwd() / ".claude"
    if not claude_dir.is_dir():
        die("diff: no .claude/ directory in current project")

    if name is None:
        marker = read_marker(claude_dir)
        if marker is None:
            die("diff: no profile name given and no active profile. Usage: ccenv diff [name]")
        name = marker[0]

    profile_dir = PROFILES_DIR / name
    if not profile_dir.is_dir():
        die(f"diff: profile '{name}' not found")

    print(f'Comparing .claude/ against profile "{name}":\n')

    any_diff = False

    # Compare files
    for f in PROFILE_FILES:
        pf = profile_dir / f
        cf = claude_dir / f
        if pf.is_file() and cf.is_file():
            if pf.read_bytes() != cf.read_bytes():
                print(f"=== {f} ===")
                diff = difflib.unified_diff(
                    file_lines(pf), file_lines(cf),
                    fromfile=f"profile:{f}", tofile=f"project:{f}",
                )
                sys.stdout.writelines(diff)
                print()
                any_diff = True
        elif pf.is_file() and not cf.is_file():
            print(f"=== {f} (only in profile) ===\n")
            any_diff = True
        elif not pf.is_file() and cf.is_file():
            print(f"=== {f} (only in project) ===\n")
            any_diff = True

    # Compare dirs
    for d in PROFILE_DIRS:
        pd = profile_dir / d
        cd = claude_dir / d
        profile_files = collect_relative_files(pd)
        project_files = collect_relative_files(cd)
        all_files = sorted(profile_files | project_files)

        for rf in all_files:
            pfp = pd / rf
            cfp = cd / rf
            if pfp.is_file() and cfp.is_file():
                if pfp.read_bytes() != cfp.read_bytes():
                    print(f"=== {d}/{rf} ===")
                    diff = difflib.unified_diff(
                        file_lines(pfp), file_lines(cfp),
                        fromfile=f"profile:{d}/{rf}", tofile=f"project:{d}/{rf}",
                    )
                    sys.stdout.writelines(diff)
                    print()
                    any_diff = True
            elif pfp.is_file() and not cfp.is_file():
                print(f"=== {d}/{rf} (only in profile) ===\n")
                any_diff = True
            elif not pfp.is_file() and cfp.is_file():
                print(f"=== {d}/{rf} (only in project) ===\n")
                any_diff = True

    if not any_diff:
        print("No differences found.")


# ─── CLI ───────────────────────────────────────────────────────────────────────

SHELL_INTEGRATION = """\
Shell integration:
  Add to your .bashrc or .zshrc to auto-apply --setting-sources:

    claude() {
      if [ -f ".claude/.profile" ]; then
        command claude --setting-sources project,local "$@"
      else
        command claude "$@"
      fi
    }"""


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="ccenv",
        description="ccenv — Claude Code Environments\n\nManage reusable configuration profiles for Claude Code.",
        epilog=SHELL_INTEGRATION,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("-v", "--version", action="version", version=f"ccenv {VERSION}")

    sub = parser.add_subparsers(dest="command", metavar="command")

    # save
    p_save = sub.add_parser("save", help="Save current config as a profile")
    p_save.add_argument("name", help="Profile name")
    p_save.add_argument("--from", dest="source", default="global", choices=["global", "project"],
                        help="Config source (default: global)")

    # use
    p_use = sub.add_parser("use", help="Apply a profile to the current project")
    p_use.add_argument("name", help="Profile name")

    # eject
    sub.add_parser("eject", help="Detach project from its profile")

    # clear
    p_clear = sub.add_parser("clear", help="Remove all managed config files (clean slate)")
    p_clear.add_argument("--scope", default="global", choices=["global", "project"],
                         help="Which config to clear (default: global)")

    # status
    sub.add_parser("status", help="Show profile state for this project")

    # update
    sub.add_parser("update", help="Re-sync project from profile template")

    # list
    sub.add_parser("list", help="List all available profiles")

    # diff
    p_diff = sub.add_parser("diff", help="Compare project config against a profile")
    p_diff.add_argument("name", nargs="?", default=None, help="Profile name (defaults to active profile)")

    return parser


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        return

    commands = {
        "save": cmd_save,
        "use": cmd_use,
        "eject": cmd_eject,
        "clear": cmd_clear,
        "status": cmd_status,
        "update": cmd_update,
        "list": cmd_list,
        "diff": cmd_diff,
    }

    commands[args.command](args)


if __name__ == "__main__":
    main()
